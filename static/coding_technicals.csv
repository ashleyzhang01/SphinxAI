Language,Name,StarterCode,Description,SampleSolution,Tests,
Python,find_min_steps,from typing import List\n\ndef find_min_steps(mat: List[List[int]]) -> int:\n,"Suppose that matrix mat contains only 'A', 'B', and '0'.\nFind the minimum number of steps such that\n (a) you start at any cell whose value is 'A' (you can choose a cell)\n (b) you end at any cell whose value is 'B' (you can choose a cell)\n (c) you can move up, down, left, and right only\n\nExample.\nInput.\nmat = [\n    ['A', '0', '0', '0'],\n    ['A', '0', '0', '0'],\n    ['0', '0', 'B', 'B']\n]\nOutput: 3\n","from typing import List\n\ndef find_min_steps(mat: List[List[int]]) -> int:\n    n_rows = len(mat)\n    n_cols = len(mat[0])\n    visited = set()\n    cur = list()\n    #get initial positions of 'A'\n    for i in range(n_rows):\n        for j in range(n_cols):\n            if mat[i][j] == 'A':\n                visited.add((i, j))\n                cur.append((i, j))\n    # bfs\n    n_steps = 0\n    while cur:\n        next_ = list()\n        for i, j in cur:\n            if mat[i][j] == 'B':\n                return n_steps\n\n            # up\n            if i > 0 and (i-1, j) not in visited:\n                next_.append((i-1, j))\n                visited.add((i-1, j))\n            # down\n            if i + 1 < n_rows and (i+1, j) not in visited:\n                next_.append((i+1, j))\n                visited.add((i+1, j))\n            # left\n            if j > 0 and (i, j-1) not in visited:\n                next_.append((i, j-1))\n                visited.add((i, j-1))\n            # right\n            if j + 1 < n_cols and (i, j+1) not in visited:\n                next_.append((i, j+1))\n                visited.add((i, j+1))\n        cur = list(next_)\n        n_steps += 1\n    return int('inf')","answers = [[[['A', '0', '0', '0'], ['A', '0', '0', '0'], ['0', '0', 'B', 'B']], 3],\n           [[['B', '0', '0'], ['0', '0', 'A']], 3],\n           [[['B'], ['A']], 1],\n           [[['0', '0', 'B'], ['A', 'A', '0']], 2],\n           [[['0', 'B'], ['0', '0'], ['A', '0']], 3]]\n\nfor args in answers:\n    args = list(args)\n    corr_ans = args.pop()\n    pred_ans = find_min_steps(*deepcopy(args))\n    assert corr_ans == pred_ans, f'For input {args}, got {pred_ans}, expected {corr_ans}'\nprint('All tests passed')",
Python,shortestPathBinaryMatrix,"from typing import List\n\n\nclass Solution:\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\n","In an N by N square grid, each cell is either empty (0) or blocked (1).\n\nA clear path from top-left to bottom-right has length k if and only if it is composed of cells C_1, C_2, ..., C_k such that:\n\nAdjacent cells C_i and C_{i+1} are connected 8-directionally (ie., they are different and share an edge or corner)\nC_1 is at location (0, 0) (ie. has value grid[0][0])\nC_k is at location (N-1, N-1) (ie. has value grid[N-1][N-1])\nIf C_i is located at (r, c), then grid[r][c] is empty (ie. grid[r][c] == 0).\nReturn the length of the shortest such clear path from top-left to bottom-right.\nIf such a path does not exist, return -1.\n\nExample 1:\nInput: [[0,1],[1,0]]\nOutput: 2\n\nExample 2:\nInput: [[0,0,0],[1,1,0],[1,1,0]]\nOutput: 4\n\nNote:\n(*) 1 <= grid.length == grid[0].length <= 100\n(*) grid[r][c] is 0 or 1\n","from typing import List\n\n\nclass Solution:\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        if grid[0][0] or grid[n - 1][n - 1]:\n            return -1\n\n        cur = [(0, 0), ]\n        visited = set(cur)\n        n_steps = 1\n        while cur:\n            next_ = list()\n            for i, j in cur:\n                if i == n - 1 and j == n - 1:\n                    return n_steps\n                # left\n                if i > 0 and (i - 1, j) not in visited and not grid[i - 1][j]:\n                    next_.append((i - 1, j))\n                    visited.add((i - 1, j))\n                # upper-left\n                if i > 0 and j > 0 and (i - 1, j - 1) not in visited and not grid[i - 1][j - 1]:\n                    next_.append((i - 1, j - 1))\n                    visited.add((i - 1, j - 1))\n                # lower-left\n                if i > 0 and j + 1 < n and (i - 1, j + 1) not in visited and not grid[i - 1][j + 1]:\n                    next_.append((i - 1, j + 1))\n                    visited.add((i - 1, j + 1))\n                # up\n                if j > 0 and (i, j - 1) not in visited and not grid[i][j - 1]:\n                    next_.append((i, j - 1))\n                    visited.add((i, j - 1))\n                # down\n                if j + 1 < n and (i, j + 1) not in visited and not grid[i][j + 1]:\n                    next_.append((i, j + 1))\n                    visited.add((i, j + 1))\n                # right\n                if i + 1 < n and (i + 1, j) not in visited and not grid[i + 1][j]:\n                    next_.append((i + 1, j))\n                    visited.add((i + 1, j))\n                # upper-right\n                if i + 1 < n and j > 0 and (i + 1, j - 1) not in visited and not grid[i + 1][j - 1]:\n                    next_.append((i + 1, j - 1))\n                    visited.add((i + 1, j - 1))\n                # lower-right\n                if i + 1 < n and j + 1 < n and (i + 1, j + 1) not in visited and not grid[i + 1][j + 1]:\n                    next_.append((i + 1, j + 1))\n                    visited.add((i + 1, j + 1))\n            cur = list(next_)\n            n_steps += 1\n        return -1\n","answers = [\n    [[[0, 1], [1, 0]], 2],\n    [[[0, 0, 0], [1, 1, 0], [1, 1, 0]], 4]\n]\n\nfor args in answers:\n    args = list(args)\n    corr_ans = args.pop()\n    pred_ans = Solution().shortestPathBinaryMatrix(*deepcopy(args))\n    assert corr_ans == pred_ans, f'For input {args}, got {pred_ans}, expected {corr_ans}'\nprint('All tests passed')",
Python,convertBST,"\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def to_list(self) -> List[int or str]:\n        level = [self, ]\n        lst = []\n        while level:\n            new_level = list()\n            for node in level:\n                if node is None:\n                    lst.append(None)\n                else:\n                    lst.append(node.val)\n                    new_level.append(node.left)\n                    new_level.append(node.right)\n            level = list(new_level)\n\n        return lst\n\n    @classmethod\n    def to_treenode(cls, arr: List[int or str] or None) -> 'TreeNode' or None:\n        if not arr or arr[0] is None:\n            return None\n\n        level = [TreeNode(arr.pop(0)), ]\n        root = level[0]\n        while level:\n            new_level = []\n            for node in level:\n                if not arr:\n                    break\n                elif arr[0] is None:\n                    arr.pop(0)\n                else:\n                    node.left = TreeNode(arr.pop(0))\n                    new_level.append(node.left)\n\n                if not arr:\n                    break\n                elif arr[0] is None:\n                    arr.pop(0)\n                else:\n                    node.right = TreeNode(arr.pop(0))\n                    new_level.append(node.right)\n            level = list(new_level)\n        return root\n\n    def __repr__(self):\n        return str(self.to_list())\n\n    def __eq__(self, other):\n        this = self\n        if this is None and other is None:\n            return True\n\n        if this is None or other is None:\n            return False\n\n        if this.val != other.val:\n            return False\n\n        return self.left == other.left and self.right == other.right\n\n\nclass Solution:\n    def convertBST(self, root: TreeNode, greater_sum: int = 0, total_sum: int = 0) -> TreeNode:\n","Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key\nof the original BST is changed to the original key plus sum of all keys greater than the\noriginal key in BST.\n\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\n\nThe left subtree of a node contains only nodes with keys less than the node's key.\nThe right subtree of a node contains only nodes with keys greater than the node's key.\nBoth the left and right subtrees must also be binary search trees.\n\nExample 1:\nInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\nExample 2:\nInput: root = [0,null,1]\nOutput: [1,null,1]\n\nExample 3:\nInput: root = [1,0,2]\nOutput: [3,3,2]\n\nExample 4:\nInput: root = [3,2,4,1]\nOutput: [7,9,4,10]\n\nConstraints:\n(*) The number of nodes in the tree is in the range [0, 10^4].\n(*) -10^4 <= Node.val <= 10^4\n(*) All the values in the tree are unique.\n(*) root is guaranteed to be a valid binary search tree.\n","class Solution:\n    def convertBST(self, root: TreeNode, greater_sum: int = 0, total_sum: int = 0) -> TreeNode:\n        if root is None:\n            return None\n\n        if root.right is not None:\n            self.convertBST(root.right, greater_sum)\n            greater_sum = root.right.val\n            node = root.right\n            while node is not None:\n                greater_sum = node.val\n                node = node.left\n\n        root.val += greater_sum\n        self.convertBST(root.left, root.val)\n        return root","answers = [\n    [[4, 1, 6, 0, 2, 5, 7, None, None, None, 3, None, None, None, 8],\n     [30, 36, 21, 36, 35, 26, 15, None, None, None, 33, None, None, None, 8]],\n    [[0, None, 1], [1, None, 1]],\n    [[1, 0, 2], [3, 3, 2]],\n    [[3, 2, 4, 1], [7, 9, 4, 10]]\n]\n\nfor i in range(len(answers)):\n    answers[i][0] = TreeNode.to_treenode(answers[i][0])\n    answers[i][1] = TreeNode.to_treenode(answers[i][1])\n\nfor args in answers:\n    args = list(args)\n    corr_ans = args.pop()\n    pred_ans = Solution().convertBST(*deepcopy(args))\n    assert corr_ans == pred_ans, f'For input {args}, got {pred_ans}, expected {corr_ans}'\nprint('All tests passed')",
Python,maxArea,"from typing import List\n\n\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n","Given n non-negative integers a1, a2, ..., an , where each represents a point at\ncoordinate (i, ai). n vertical lines are drawn such that the two endpoints of the\nline i is at (i, ai) and (i, 0). Find two lines, which, together with the x-axis\nforms a container, such that the container contains the most water.\n\nNotice that you may not slant the container.\n\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7].\nIn this case, the max area of water (blue section) the container can contain is 49.\n\nExample 2:\nInput: height = [1,1]\nOutput: 1\n\nExample 3:\nInput: height = [4,3,2,1,4]\nOutput: 16\n\nExample 4:\nInput: height = [1,2,1]\nOutput: 2\n\n\nConstraints:\n(*) n == height.length\n(*) 2 <= n <= 3 * 10^4\n(*) 0 <= height[i] <= 3 * 10^4\n","from typing import List\n\n\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        # the optimal area enclosed is bounded by the left and right pillars\n        # find the candidates for them\n        consider_for_left = []  # list of tuples (height, x-coord)\n        for i, h in enumerate(height):\n            # if one of the previous pillars were taller than the current,\n            # choosing previous pillar will only increase the enclosed area\n            if not consider_for_left or consider_for_left[-1][0] < h:\n                consider_for_left.append((h, i))\n        consider_for_right = []  # list of tuples (height, x-coord)\n        for i, h in enumerate(reversed(height)):\n            # going from right to left\n            # if one of the previous pillars were taller than the current,\n            # choosing previous pillar as the right pillar will only increase the enclosed area\n            if not consider_for_right or consider_for_right[-1][0] < h:\n                consider_for_right.append((h, len(height) - 1 - i))\n\n        max_area = 0\n        # we have the list of potential left pillars\n        # inside the list, heights of pillars are increasing, and x-coords are increasing\n        # potential right pillars: heights are increasing, x-coords are decreasing\n        i_left = 0\n        i_right = 0\n        while i_left < len(consider_for_left) and i_right < len(consider_for_right) and consider_for_left[i_left][1] <                 consider_for_right[i_right][1]:\n            height_left = consider_for_left[i_left][0]\n            x_left = consider_for_left[i_left][1]\n            height_right = consider_for_right[i_right][0]\n            x_right = consider_for_right[i_right][1]\n            area = min(height_left, height_right) * (x_right - x_left)\n            max_area = max(area, max_area)\n            if height_left <= height_right:\n                # all pillars in consider_for_right[i_right:] are taller or equal then consider_for_left[i_left]\n                # therefore, if consider_for_left[i_left] is the optimal left pillar, then the enclosed area\n                # is maximized when i_right is as above.\n                # proceed to the next pillar in consider_for_left\n                i_left += 1\n            else:\n                # all pillars in consider_for_left[i_left:] are taller or equal then consider_for_left[i_right]\n                # therefore, if consider_for_left[i_right] is the optimal right pillar, then the enclosed area\n                # is maximized when i_left is as above.\n                # proceed to the next pillar in consider_for_right\n                i_right += 1\n        return max_area","answers = [\n    [[1, 8, 6, 2, 5, 4, 8, 3, 7], 49],\n    [[1, 1], 1],\n    [[4, 3, 2, 1, 4], 16],\n    [[1, 2, 1], 2]\n]\n\nfor args in answers:\n    args = list(args)\n    corr_ans = args.pop()\n    pred_ans = Solution().maxArea(*deepcopy(args))\n    assert corr_ans == pred_ans, f'For input {args}, got {pred_ans}, expected {corr_ans}'\nprint('All tests passed')",
Python,isBalancedTree,"class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    def to_list(self) -> List[int or str]:\n        level = [self, ]\n        lst = []\n        while level:\n            new_level = list()\n            for node in level:\n                if node is None:\n                    lst.append(None)\n                else:\n                    lst.append(node.val)\n                    new_level.append(node.left)\n                    new_level.append(node.right)\n            level = list(new_level)\n\n        return lst\n\n    @classmethod\n    def to_treenode(cls, arr: List[int or str] or None) -> 'TreeNode' or None:\n        if not arr or arr[0] is None:\n            return None\n\n        level = [TreeNode(arr.pop(0)), ]\n        root = level[0]\n        while level:\n            new_level = []\n            for node in level:\n                if not arr:\n                    break\n                elif arr[0] is None:\n                    arr.pop(0)\n                else:\n                    node.left = TreeNode(arr.pop(0))\n                    new_level.append(node.left)\n\n                if not arr:\n                    break\n                elif arr[0] is None:\n                    arr.pop(0)\n                else:\n                    node.right = TreeNode(arr.pop(0))\n                    new_level.append(node.right)\n            level = list(new_level)\n        return root\n\n    def __repr__(self):\n        return str(self.to_list())\n\n    def __eq__(self, other):\n        this = self\n        if this is None and other is None:\n            return True\n\n        if this is None or other is None:\n            return False\n\n        if this.val != other.val:\n            return False\n\n        return self.left == other.left and self.right == other.right\n\n\nclass Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n","Given a binary tree, determine if it is height-balanced.\n\nFor this problem, a height-balanced binary tree is defined as:\n\na binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n\nExample 1.\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\n\nExample 2.\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n\nExample 3:\nInput: root = []\nOutput: true\n\n\nConstraints:\n(*) The number of nodes in the tree is in the range [0, 5000].\n(*)-10^4 <= Node.val <= 10^4\n","class Solution:\n    def isBalancedTree(self, root: TreeNode) -> bool:\n        if root is None: return True\n\n        if root.left is not None:\n            is_left_balanced = self.isBalanced(root.left)\n            left_depth = root.left.depth\n        else:\n            is_left_balanced = True\n            left_depth = 0\n\n        if root.right is not None:\n            is_right_balanced = self.isBalanced(root.right)\n            right_depth = root.right.depth\n        else:\n            is_right_balanced = True\n            right_depth = 0\n\n        # determine the depth\n        root.depth = max(right_depth, left_depth) + 1\n\n        # determine if the node is balanced\n        root.is_balanced = is_left_balanced and is_right_balanced and abs(right_depth - left_depth) <= 1\n        return root.is_balanced","answers = [\n    [[3, 9, 20, None, None, 15, 7], True],\n    [[1, 2, 2, 3, 3, None, None, 4, 4], False],\n    [[], True]\n]\nanswers = [\n    [TreeNode.to_treenode(lst), ans] for lst, ans in answers\n]\n\nfor args in answers:\n    args = list(args)\n    corr_ans = args.pop()\n    pred_ans = Solution().isBalancedTree(*deepcopy(args))\n    assert corr_ans == pred_ans, f'For input {args}, got {pred_ans}, expected {corr_ans}'\nprint('All tests passed')",
Python,ladderLength,"from typing import List\n\n\nclass Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.neighb = list()\n\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n","Given two words beginWord and endWord, and a dictionary wordList, return the length of the shortest transformation sequence from beginWord to endWord, such that:\n(1) Only one letter can be changed at a time.\n(2) Each transformed word must exist in the word list.\nReturn 0 if there is no such transformation sequence.\n","from typing import List\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n\n        memo = dict()\n        for word in wordList:\n            for i, char in enumerate(word):\n                encoded = word[:i] + '*' + word[i + 1:]\n                if encoded in memo:\n                    memo[encoded].add(word)\n                else:\n                    memo[encoded] = {word}\n\n        # find neighbor words to beginWord\n        cur = {beginWord}\n        visited = set()\n        steps = 1\n        while cur:\n            steps += 1\n            new = set()\n            for word in cur:\n                for i in range(len(word)):\n                    encoded = word[:i] + '*' + word[i + 1:]\n                    if encoded not in visited:\n                        new = new | memo.get(encoded, set())\n                        visited.add(encoded)\n            if endWord in new:\n                return steps\n\n            cur = set(new)\n        return 0","solve = Solution().ladderLength\n    correct_ans = [\n        (\""hit\"", \""cog\"", [\""hot\"", \""dot\"", \""dog\"", \""lot\"", \""log\"", \""cog\""], 5),\n        (\""hit\"", \""cog\"", [\""hot\"", \""dot\"", \""dog\"", \""lot\"", \""log\""], 0),\n    ]\n    for beginWord, endWord, wordList, corr_ans in correct_ans:\n        pred_ans = solve(beginWord, endWord, wordList)\n        assert pred_ans == corr_ans, f'For beginWord={beginWord}, endWord={endWord},\n wordList={wordList}, got answer {pred_ans}, expected {corr_ans}'\n    print('Passed all tests')",
Python,movesToStamp,"from typing import List\n\n\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n","You want to form a target string of lowercase letters.\n\nAt the beginning, your sequence is target.length '?' marks.  You also have a stamp\nof lowercase letters.\n\nOn each turn, you may place the stamp over the sequence, and replace every letter\nin the sequence with the corresponding letter from the stamp.  You can make up to\n10 * target.length turns.\n\nFor example, if the initial sequence is \""?????\"", and your stamp is \""abc\"",  then\nyou may make \""abc??\"", \""?abc?\"", \""??abc\"" in the first turn.  (Note that the stamp\nmust be fully contained in the boundaries of the sequence in order to stamp.)\n\nIf the sequence is possible to stamp, then return an array of the index of the\nleft-most letter being stamped at each turn.  If the sequence is not possible to\nstamp, return an empty array.\n\nFor example, if the sequence is \""ababc\"", and the stamp is \""abc\"", then we could\nreturn the answer [0, 2], corresponding to the moves \""?????\"" -> \""abc??\"" -> \""ababc\"".\n\nAlso, if the sequence is possible to stamp, it is guaranteed it is possible\nto stamp within 10 * target.length moves.  Any answers specifying more than this\nnumber of moves will not be accepted.\n\nExample 1:\nInput: stamp = \""abc\"", target = \""ababc\""\nOutput: [0,2]\n([1,0,2] would also be accepted as an answer, as well as some other answers.)\n\nExample 2:\nInput: stamp = \""abca\"", target = \""aabcaca\""\nOutput: [3,0,1]\n","from typing import List\n\n\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        if len(stamp) > len(target):\n            return list()\n\n        self.stamp = stamp\n        self.stamp_pattern = [[char, '*'] for char in stamp]\n        self.target = list(target) # to make it mutable\n        n_chars_to_change = len(target)\n        sequence = []\n        while n_chars_to_change:\n            i = self.find_matching_stamp()\n            if i < 0:\n                return []\n\n            # put stamp at location i\n            sequence.append(i)\n            # change letters in target\n            j = 0\n            while j < len(stamp):\n                if self.target[i + j] != '*':\n                    n_chars_to_change -= 1\n                    self.target[i + j] = '*'\n                j += 1\n\n        sequence.reverse()\n        return sequence\n\n    def match_stamp(self, i: int) -> bool:\n        j = 0\n        is_letter = False\n        while j < len(self.stamp) and self.target[i+j] in self.stamp_pattern[j]:\n            if self.target[i + j] != '*':\n                is_letter = True\n            j += 1\n        return j == len(self.stamp) and is_letter\n\n    def find_matching_stamp(self) -> int:\n        '''\n        returns the index where stamp matches target or -1 if there is no match\n        '''\n        i = 0\n        while i <= len(self.target) - len(self.stamp) and not self.match_stamp(i):\n            i += 1\n        return i if i <= len(self.target) - len(self.stamp) else -1","answers = [\n    [\""abc\"", \""ababc\"", [0, 2]],\n    [\""abca\"", \""aabcaca\"", [3,0,1]]\n]\n\nfor args in answers:\n    args = list(args)\n    corr_ans = args.pop()\n    pred_ans = Solution().movesToStamp(*deepcopy(args))\n    assert corr_ans == pred_ans, f'For input {args}, got {pred_ans}, expected {corr_ans}'\nprint('All tests passed')",
Python,minEditDistance,"class Solution:\n    def minEditDistance(self, word1: str, word2: str) -> int\n","Given two strings word1 and word2, return the minimum number\nof operations required to convert word1 to word2.\n\nYou have the following three operations permitted on a word:\n* Insert a character\n* Delete a character\n* Replace a character\n\n\nExample 1:\nInput: word1 = \""horse\"", word2 = \""ros\""\nOutput: 3\nExplanation:\nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\nExample 2:\nInput: word1 = \""intention\"", word2 = \""execution\""\nOutput: 5\nExplanation:\nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n\nConstraints:\n(*) 0 <= word1.length, word2.length <= 500\n(*) word1 and word2 consist of lowercase English letters.\n","from typing import List\n\n\nclass Solution:\n    def movesToStamp(self, stamp: str, target: str) -> List[int]:\n        if len(stamp) > len(target):\n            return list()\n\n        self.stamp = stamp\n        self.stamp_pattern = [[char, '*'] for char in stamp]\n        self.target = list(target) # to make it mutable\n        n_chars_to_change = len(target)\n        sequence = []\n        while n_chars_to_change:\n            i = self.find_matching_stamp()\n            if i < 0:\n                return []\n\n            # put stamp at location i\n            sequence.append(i)\n            # change letters in target\n            j = 0\n            while j < len(stamp):\n                if self.target[i + j] != '*':\n                    n_chars_to_change -= 1\n                    self.target[i + j] = '*'\n                j += 1\n\n        sequence.reverse()\n        return sequence\n\n    def match_stamp(self, i: int) -> bool:\n        j = 0\n        is_letter = False\n        while j < len(self.stamp) and self.target[i+j] in self.stamp_pattern[j]:\n            if self.target[i + j] != '*':\n                is_letter = True\n            j += 1\n        return j == len(self.stamp) and is_letter\n\n    def find_matching_stamp(self) -> int:\n        '''\n        returns the index where stamp matches target or -1 if there is no match\n        '''\n        i = 0\n        while i <= len(self.target) - len(self.stamp) and not self.match_stamp(i):\n            i += 1\n        return i if i <= len(self.target) - len(self.stamp) else -1","answers = [\n    ['horse', 'ros', 3],\n    ['intention', 'execution', 5],\n]\n\nfor args in answers:\n    args = list(args)\n    corr_ans = args.pop()\n    pred_ans = Solution().minEditDistance(*deepcopy(args))\n    assert corr_ans == pred_ans, f'For input {args}, got {pred_ans}, expected {corr_ans}'\nprint('All tests passed')",
Java,countPairs,"import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    List<Integer>[] graph;\n    boolean[] visited;\n    int count;\n\n    public long countPairs(int n, int[][] edges) {\n","You are given an integer n. There is an undirected graph with n nodes, numbered from 0 to n - 1. You are given a 2D integer array edges where edges[i] = [a_i, b_i] denotes that there exists an undirected edge connecting nodes a_i and b_i.\n\nReturn the number of pairs of different nodes that are unreachable from each other.\n\nExample 1:\nInput: n = 3, edges = [[0,1],[0,2],[1,2]]\nOutput: 0\nExplanation: There are no pairs of nodes that are unreachable from each other. Therefore, we return 0.\n\nExample 2:\nInput: n = 7, edges = [[0,2],[0,5],[2,4],[1,6],[5,4]]\nOutput: 14\nExplanation: There are 14 pairs of nodes that are unreachable from each other:\n[[0,1],[0,3],[0,6],[1,2],[1,3],[1,4],[1,5],[2,3],[2,6],[3,4],[3,5],[3,6],[4,6],[5,6]].\nTherefore, we return 14.\n","class Solution {\n    List<Integer>[] graph;\n    boolean[] visited;\n    int count;\n\n    public long countPairs(int n, int[][] edges) {\n        graph = new List[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        for (int[] edge : edges) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        visited = new boolean[n];\n        long res = 0L;\n        for (int i = 0, total = 0; i < n; i++) {\n            if (!visited[i]) {\n                count = 0;\n                dfs(i);\n                res += (long) count * total;\n                total += count;\n            }\n        }\n        return res;\n    }\n\n    private void dfs(int x) {\n        visited[x] = true;\n        count++;\n        for (int y : graph[x]) {\n            if (!visited[y]) {\n                dfs(y);\n            }\n        }\n    }\n}","\nclass Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n    \n        int n1 = 3;\n        int[][] edges1 = {{0, 1}, {0, 2}, {1, 2}};\n        long expected1 = 0;\n        long actual1 = solution.countPairs(n1, edges1);\n        if (actual1 != expected1) {\n            System.out.println(\""Test failed: Expected \"" + expected1 + \"", but got \"" + actual1 + \"".\"");\n        }\n    \n        int n2 = 7;\n        int[][] edges2 = {{0, 2}, {0, 5}, {2, 4}, {1, 6}, {5, 4}};\n        long expected2 = 14;\n        long actual2 = solution.countPairs(n2, edges2);\n        if (actual2 != expected2) {\n            System.out.println(\""Example failed: Expected \"" + expected2 + \"", but got \"" + actual2 + \"".\"");\n        }\n        if (actual1 == expected1 && actual2 == expected2) {\n            System.out.println(\""All tests passed\"");\n        }\n    }\n}",
Java,minScorePath,"import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n\n    public int minScore(int n, int[][] roads) {\n ","You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [a_i, b_i, distance_i] indicates that there is a bidirectional road between cities a_i and b_i with a distance equal to distance_i. The cities graph is not necessarily connected.\n\nThe score of a path between two cities is defined as the minimum distance of a road in this path.\n\nReturn the minimum possible score of a path between cities 1 and n.\n\nNote:\nA path is a sequence of roads between two cities.\nIt is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\nThe test cases are generated such that there is at least one path between 1 and n.\n\nExample:\nInput: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\nOutput: 5\nExplanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.\nIt can be shown that no other path has less score.\n","class Solution {\n    int res = Integer.MAX_VALUE;\n\n    public int minScore(int n, int[][] roads) {\n        List<List<int[]>> list = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            list.add(new ArrayList<>());\n        }\n        for (int[] road : roads) {\n            int s = road[0] - 1;\n            int d = road[1] - 1;\n            int weight = road[2];\n            list.get(s).add(new int[]{d, weight});\n            list.get(d).add(new int[]{s, weight});\n        }\n        boolean[] visited = new boolean[n];\n        dfs(list, 0, visited);\n        return res;\n    }\n\n    private void dfs(List<List<int[]>> list, int start, boolean[] visited) {\n        if (visited[start]) {\n            return;\n        }\n        visited[start] = true;\n        for (int[] next : list.get(start)) {\n            if (res > next[1]) {\n                res = next[1];\n            }\n            dfs(list, next[0], visited);\n        }\n    }\n}\n","\nclass Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        int n1 = 4;\n        int[][] roads1 = {{1, 2, 9}, {2, 3, 6}, {2, 4, 5}, {1, 4, 7}};\n        long expected1 = 5;\n        long actual1 = solution.minScore(n1, roads1);\n        if (actual1 != expected1) {\n            System.out.println(\""Test failed: Expected \"" + expected1 + \"", but got \"" + actual1 + \"".\"");\n        }\n\n        int n2 = 4;\n        int[][] roads2 = {{1, 2, 2}, {1, 3, 4}, {3, 4, 7}};\n        long expected2 = 2;\n        long actual2 = solution.minScore(n2, roads2);\n        if (actual2 != expected2) {\n            System.out.println(\""Example failed: Expected \"" + expected2 + \"", but got \"" + actual2 + \"".\"");\n        }\n        if (actual1 == expected1 && actual2 == expected2) {\n            System.out.println(\""All tests passed\"");\n        }\n    }\n}",
Java,minimumRoundsToCompleteAllTasks,import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n\n    public int minimumRounds(int[] tasks) {\n,"You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level.\n\nReturn the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.\n\nExample 1:\n\nInput: tasks = [2,2,3,3,2,4,4,4,4,4]\nOutput: 4\nExplanation: To complete all the tasks, a possible plan is:\n- In the first round, you complete 3 tasks of difficulty level 2.\n- In the second round, you complete 2 tasks of difficulty level 3.\n- In the third round, you complete 3 tasks of difficulty level 4.\n- In the fourth round, you complete 2 tasks of difficulty level 4.\nIt can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.\n","\nclass Solution {\n    public int minimumRounds(int[] tasks) {\n        Map<Integer, Integer> freq = new HashMap<>();\n        for (int i = 0; i < tasks.length; i++)\n            freq.put(tasks[i], freq.getOrDefault(tasks[i], 0) + 1);\n\n        int ans = 0;\n        for (int count : freq.values()) {\n            if (count == 1)\n                return -1;\n            if (count % 3 == 0)\n                ans += count / 3;\n            else\n                ans += count / 3 + 1;\n        }\n\n        return ans;\n    }\n}\n","\nclass Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        int[] tasks1 = {2, 2, 3, 3, 2, 4, 4, 4, 4, 4};\n        long expected1 = 4;\n        long actual1 = solution.minimumRounds(tasks1);\n        if (actual1 != expected1) {\n            System.out.println(\""Test failed: Expected \"" + expected1 + \"", but got \"" + actual1 + \"".\"");\n        }\n\n        int[] tasks2 = {2, 3, 3};\n        long expected2 = -1;\n        long actual2 = solution.minimumRounds(tasks2);\n        if (actual2 != expected2) {\n            System.out.println(\""Example failed: Expected \"" + expected2 + \"", but got \"" + actual2 + \"".\"");\n        }\n        if (actual1 == expected1 && actual2 == expected2) {\n            System.out.println(\""All tests passed\"");\n        }\n    }\n}",
Java,findPlayersWithZeroOrOneLossesTest,import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n\n    public List<List<Integer>> findWinners(int[][] matches) {\n,"You are given an integer array matches where matches[i] = [winner_i, loser_i] indicates that the player winner_i defeated player loser_i in a match.\n\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\nThe values in the two lists should be returned in increasing order.\n\nNote:\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.\nExample 1:\n\nInput: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].\n","class Solution {\n    public List<List<Integer>> findWinners(int[][] matches) {\n        Map<Integer, Integer> lossesCnt = new HashMap<>();\n\n        for (int[] match : matches) {\n            lossesCnt.put(match[0], lossesCnt.getOrDefault(match[0], 0));\n            lossesCnt.put(match[1], lossesCnt.getOrDefault(match[1], 0) + 1);\n        }\n\n        List<List<Integer>> ans = Arrays.asList(new ArrayList<>(), new ArrayList<>());\n        for (Integer player : lossesCnt.keySet()) {\n            if (lossesCnt.get(player) == 0) {\n                ans.get(0).add(player);\n            } else if (lossesCnt.get(player) == 1) {\n                ans.get(1).add(player);\n            }\n        }\n\n        Collections.sort(ans.get(0));\n        Collections.sort(ans.get(1));\n\n        return ans;\n    }\n}\n","class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        int[][] matches1 = {{2, 3}, {1, 3}, {5, 4}, {6, 4}};\n        List<List<Integer>> expectedResults1 = new ArrayList<>();\n        expectedResults1.add(Arrays.asList(1, 2, 5, 6));\n        expectedResults1.add(new ArrayList<>());\n        List<List<Integer>> actual1 = solution.findWinners(matches1);\n        if (!actual1.equals(expectedResults1)) {\n            System.out.println(\""Test failed: Expected \"" + expectedResults1 + \"", but got \"" + actual1 + \"".\"");\n        }\n\n        int[][] matches2 = {{1, 3}, {2, 3}, {3, 6}, {5, 6}, {5, 7}, {4, 5}, {4, 8}, {4, 9}, {10, 4}, {10, 9}};\n        List<List<Integer>> expectedResults2 = new ArrayList<>();\n        expectedResults2.add(Arrays.asList(1, 2, 10));\n        expectedResults2.add(Arrays.asList(4, 5, 7, 8));\n        List<List<Integer>> actual2 = solution.findWinners(matches2);\n        if (!actual2.equals(expectedResults2)) {\n            System.out.println(\""Example failed: Expected \"" + expectedResults2 + \"", but got \"" + actual2 + \"".\"");\n        }\n        if (actual1.equals(expectedResults1) && actual2.equals(expectedResults2)) {\n            System.out.println(\""All tests passed\"");\n        }\n    }\n}",